\section{Coding Guide}

There are only two kinds of code: commercial-quality code and throwaway code. 

Legible code reduces the cost of development and maintenance by making the code's purpose clear which reduces the time needed to train new developers as well as making many bugs glaringly apparent. "Legibility" is not a post-modern concept anyone can define for themselves, but rather is defined by the known idioms and standard practices of the programming community. Aesthetic judgments are important, and at times writing legible code requires breaking from community traditions, but doing this should always be the result of forethought and never done simply for ``convenience''.

Rather than reiterating other style guides, the reader is referred in particular to \cite{ambysoft,geosoft}, which should be considered required reading. The rest of this document serves to summarize some important points for quick reference, and to highlight topics which not covered by those guides or for which we are using different standards. The standard legalistic distinction between ``must''/``shall'' (absolute requirement) vs ``should'' (strongly desired behavior) vs ``may''/``can'' (permissible behavior) is in force throughout this document. 


\subsection{Terminology}

This document uses the following standard terminology. Most of these terms come straight from \href{http://java.sun.com/docs/glossary.html}{Sun's Java Glossary}, though attribute and entity come from the larger programming languages community. 

 \begin{description}
 \item[Field] a variable defined for an object instance. (Called a data member in C++ parlance.)
 \item[Class Variable] a shared variable defined for all instances of a class. (Also called a static field.)
 \item[Attribute] an actual or `imagined' field which are accessed by setter and getter methods.
 \item[Method] an operation defined on an object instance. (Called a member function in C++)
 \item[Class Method] an operation defined on a class itself. (Also called a static method.)
 \item[Parameter] a variable which is received as the argument to a method.
 \item[Argument] an expression (including variables and literals) which is passed in when calling a method.
 \item[Variable] always a local variable unless otherwise specified.
 \item[Constant] a `final' variable. Should be used sparingly.
 \item[Entity] any thing which exists in the language, can be defined, and can be given a name (e.g. all of the above) 
 \end{description}


\subsubsection{Abstract Base Class vs Interface}
An {\bf abstract} (base/super) class is a class which can create no object instances. An {\bf interface} is a collection of methods indicating a coherent functionality which a class may implement. Classes can extend only one super class, however they may implement multiple interfaces. For those familiar with other object-oriented languages, Java interfaces are wholly abstract and may not even provide default implementations using the rest of the interface, Java also lacks support for mixins (though there are ways to fake them). For more information on the details, see the \href{http://java.sun.com/docs/books/jls/second_edition/html/jTOC.doc.html}{Java language specification}.

In most circumstances interfaces are preferred over abstract classes because they place fewer restrictions on the implementations for subtypes. However, this can lead to much duplicated effort due to Java's limitations. Whenever crossing package or other modularity boundaries, an interface should be defined to capture the necessary methods, and additionally an abstract class should be provided implementing that interface in an obvious manner for easy subclassing. For an interface {\tt Foo} the abstract class shall be called {\tt DefaultFoo}.

Before running headlong toward either interfaces or abstract classes, developers should recall standard object-oriented \href{http://en.wikipedia.org/wiki/Design_pattern_(computer_science)}{design patterns}. In particular the visitor pattern can be used to apply an abstract algebra to recursive structures like trees, tries, and linked lists. The factory pattern can be used to simulate mixins and similar things. And the command pattern captures the idea of objects as functions. When ensuring modularity and extensibility, these patterns often increase the clarity and organization of code with minimal overhead costs. 

\subsection{Code Editors}

There are many decent editors out there. It is perfectly fine to require that developers use some such editor. It is not acceptable, however, to require one specific editor for code to be considered legible, especially not for an open-source project. Throughout this document occasional references are made to features which "any decent editor" should have. Unfortunately, without extensive IDE support it is nearly impossible to write large amounts of Java and maintain your sanity. We will make reasonable efforts not to constrain your choice of editor, but if it lacks these features you should seriously consider finding a better editor. 


\subsection{Comments, Clarity, and Obfuscation}

Comments are a good thing. Documentation is better. Every entity shall have a JavaDoc comment explaining its use. The comment should explain what the method does, not how it does it. How the code operates is clear because the code is blindingly obvious, and besides it is subject to frequent changes. What the code does is part of the specification of the API provided to the rest of the system. Clients need not know how a library is implemented, but they do need to know how to use it.

Code should be written so it is blindingly obvious how it works. In many cases, comments written within a method should be avoided; this is not meant to discourage documentation --- rather, such comments tend to be indicative of poorly written code which needs explanation. Often this can be repaired simply by changing a name, restructuring a statement, or breaking out a new method. If it takes more than 30 seconds to understand what a method is doing, the method is wrong and needs to be rewritten. This does not mean understanding every nuance of the paper it was based on, or why it was implemented that particular way. Rather, it means that someone who knows Java but has not seen the code before could understand what is happening.

\href{http://www.haskell.org/haskellwiki/Means_of_expression}{Means of expression} is a brief guide that should be considered required reading. You don't need to know Haskell to understand what it says. Names of entities not only provide a contract which is verified by the compiler, they are also what developers see over and over, and in files far from where the entity is defined. Comments are verified by nothing, too often out of date, and written only once at the definition site which is of no use when trying to understand code which uses the entity. Therefore all entity names shall be as clear, meaningful, descriptive, and unambiguous as possible. (If they are longer than 15 characters it is very unlikely they are clear.)

When the opening brace for a block is more than a screenful away, closing braces should have a brief comment indicating what is being closed, especially if many braces are being closed at once. Any decent editor can indicate the matching brace, but since it's more than a screen away it is often clearer just to comment. Anonymous and private classes may have a comment on their closing brace, but methods and top-level classes shall not.

Large hunks of commented out code shall be removed. They are confusing since it is unclear why they were left in place or whether they might be uncommented in the near future. If the purpose is to toggle between different implementations, subclassing should be used instead and client code should have a flag for choosing which implementation to use. If the purpose is for toggling debugging, then the appropriate mechanism for debugging should be used instead. If the dead code ever becomes needed again, the versioning repository has copies of it. 



\subsection{Naming Conventions}

\begin{description}
\item[Packages] in underscore\_case
\item[Classes] nouns in StudlyCaps. When true nouns are not available or clear, agentive nouns (e.g. "Parser") shall be used instead of gerunds (e.g. ``Parsing''). Abstract classes implementing an interface should have the prefix `Default', e.g. for an interface Foo the abstract class would be DefaultFoo.
\item[Interfaces] properties or capabilities in StudlyCaps. (e.g. anything ending in -able)
\item[Methods] verbs in camelCase
\item[Fields and Class Variables] in camelCase. Always use this. when on the left hand side of assignment.
\item[Variables and Parameters] in camelCase. When a parameter denotes a generic instance of a class type it should be a camelCase spelling of the class name, e.g. foo(Item item).
\item[Constants] in UPPERSCORE\_CASE 
\end{description}

Acronyms shall be treated as words. That is, the first letter is capitalized in StudlyCaps or lower case in camelCase, but the rest of the acronym is in lower case. ((Exception for two letter acronyms?)) Abbreviations for words should be avoided. The name of the object/class is implicit and should not be repeated in method (or field) names.

Some decent editors will distinguish fields and class variables from variables and parameters by syntax highlighting. But not all decent editors have this particular built in support for Java. Therefore, to maintain blinding clarity, whenever a field or class variable is assigned to it shall have this. written explicitly.

Common prefixes for methods and fields are:

\begin{description}
\item[set] a method to assign or reset an attribute value
\item[get] a method to retrieve an attribute value
\item[is] a boolean field, method, or variable. Avoid negative booleans.
\item[can] a boolean field, method, or variable denoting a capability. (Prefer 'is' unless 'can' makes the name clearer.)
\item[compute] a potentially time consuming method to calculate something
\item[find] a simple lookup method
 \item[initialize] a method to establish an object, concept, or attribute; or to vacate an extant instance for reuse. Avoid the abbreviation 'init'. 
\end{description}

For more good advice see the required readings. 


\subsection{Line Width}

It is strongly recommended that lines should not be longer than 80 characters. Comments should line wrap at between 65 and 75 characters. The Unix {\tt fmt} utility is indispensable for this (and any decent editor should allow you to call it directly). Code lines generally look best at 40--50 characters wide, though with indentation or for formal parameter lists 60--70 characters is also acceptable.

While monitors allow for very wide pages these days, and while many editors support soft line-wrapping, not all editors do and it is much easier for humans to read narrower columns. When columns are too wide it can be difficult to follow the structure of code or to quickly find the next line of a comment. This also helps keep code legible for users with visual disabilities or impairments.

\subsubsection{URLs}
URLs can sometimes get very long and they are not usually amenable to being broken up across lines. For this reason, urls may exceed the otherwise hard limit for line wrapping. However, to minimize this, urls should always be set on a separate line. 


\subsection{Indentation, Braces, and Whitespace}

Whitespace is your friend. All operators shall have whitespace separating them from preceding and following tokens. Don't be afraid of blank lines. But do use your whitespace judiciously; when it's scattered carelessly it detracts from the organization of the code.

For indentation a single hard-tab shall be used, not spaces. If you are used to using spaces, any decent editor can be configured to automatically convert spaces into hard-tabs.

For all blocks the opening brace shall be on the same line as the {\tt if}, {\tt else}, {\tt for}, {\tt while} or similar. For conditionals the closing brace shall be on the same line as the {\tt else} (similarly for {\tt try}-{\tt catch}-{\tt finally}). For classes and methods, on the same line as the header is preferred, though it is permissible to set the brace on the following line at the same indentation level as the header when the header exceeds the line width regulations and must be wrapped.

The single-statement, non-block form of conditionals and loops is bug prone. Often developers will add another statement to the indented ``block'' and may not notice they must add braces first. For this reason it shall be avoided whenever possible. 


\subsection{Logging}

Java's {\tt Logger} class should be used when there is a need to print debug statements, messages, and warnings. This class should be used instead printing directly to {\tt System.out} and {\tt System.err}. Doing so gives users a great deal of flexibility regarding which messages they are presented with.

In many cases, a message to be logged will need to be constructed. This construction takes time and computing resources which should only be used if logging at the specified level is enabled. To save resources, in such situations calls to the logger should be wrapped in an {\tt if (logger.isLoggable(Level.FOO))} conditional to prevent unnecessary string construction.

However, when the string sent to the logging method is a constant, do not use the {\tt if (logger.isLoggable(Level.FOO))} conditional. There is no cost for constructing a constant string, so the guard is just boilerplate.

When you are about to call {\tt System.exit}, always use the severe level of logging (not {\tt System.out.println}). And don't use the conditional even if the string is costly to construct.; the program is about to crash, who cares about saving fractions of a second at this point? 


\subsection{Access Scope and Performance}

Whenever possible, fields shall be protected or private. Instead of more liberal access permissions, setters and getters should be used since this allows the underlying implementation to remain modular, retains access control abilities (i.e. a getter but no setter), gives the ability to do sanity checks before accepting a new value for a field, and many other benefits. When accessing an object instance's own fields the setters and getters do not need to be used, though using them does allow for future code to add sanity checks etc without needing to update code spread over the entire class.

Unfortunately, there is a modest performance penalty for writing proper code (on the order of 150--300x(!!!) times accessing the field directly). Because of this, for certain performance critical inner loops it may be necessary to give certain fields package-private access (i.e. the unnamed default access level, which is similar to ``friendly'' access in C++). This should be done as sparingly as possible and shall be clearly documented. If this is done, benchmarks should be provided to demonstrate the extent of the effect.

Fields shall never be public. (Static final constants can be public.) If a class from another package needs direct access to fields for performance reasons, this indicates a design failure in the package/class API. Perhaps the looping construct should be a new method of the underlying class, or perhaps the offending user or the underlying class should be moved so they're in the same package. 